# 最小公倍数

### 题目描述

贝拉弗向娜娜奇提出了这样一个问题：

给出两个整数 $n,m$，再给出 $n$ 个正整数 $1\le a_1 < a_2 < \cdots < a_n\le m$。

你需要求出 $1,2,\cdots,a_1-1,a_1+1,\cdots,a_2-1,a_2+1,\cdots ,a_n-1,a_n+1,\cdots ,m$ 的最小公倍数。通俗的说，你要求出 1 到 m 的所有正整数中扣掉 $a_1,a_2,\cdots,a_n$ 后剩余所有整数的最小公倍数。

娜娜奇回答错误，但是聪明的你一定能做出来！

由于答案很大，你只要输出答案对 $998234353$ 取模后的结果。

### 输入格式

第一行两个整数 $n,m$。

第二行 $n$ 个整数表示 $a_1,a_2,\cdots,a_n$。

### 输出格式

一行一个整数表示答案对 $998234353$ 取模后的结果。

### 数据范围

对于所有数据，满足 $0\le n\le 10^5,1\le m\le 3\times10^6$

| 数据点编号 | n 的范围 | m 的范围 |
| --- | --- | --- |
| 1,2 | $n\le 10$ | $m\le 10$ |
| 3 | $n=0$ | $m \le 200$ |
| 4,5,6 | $n\le 200$ | $m\le 200$ |
| 7,8,9 | $n \le 1000$ | $m\le 2000$ |
| 10,11,12,13 | $n\le 1\times 10^5$ | $m\le 10^5$ |
| 14,15 | $n=0$ | $m\le 10^5$ |
| 16,17 | $n\le 10^5$ | $m\le 10^6$ |
| 18,19,20 | $n\le 10^5$ | $m\le 3\times 10^6$ |

<div style="page-break-after: always"></div>

### 题解
若干个数的最小公倍数可以通过对这些数进行质因数分解，然后求每个质数的最大指数，最后还原即可。

要求多个数的最小公倍数（Least Common Multiple, LCM），可以使用它们的质因数分解来求解。下面是一个详细的步骤说明：

1. **分解质因数**：首先，将每个数分解成质因数的乘积。例如，将 $20$ 分解为 $2^2 \times 5$。

2. **列出所有质因数**：接着，列出所有数中出现的质因数，并且对于每个质因数，取其最高的幂次。例如，如果你需要找到 $20$ 和 $30$ 的LCM，你会先分解这两个数：
   - $20$ = $2^2 \times 5$
   - $30$ = $2 \times 3 \times 5$

   在这个例子中，质因数有 $2,3,5$。其中， $2$ 的最高幂次是 $2^2$（出现在20中）， $3$ 的最高幂次是 $3^1$（出现在30中）， $5$ 的最高幂次是 $5^1$（在 $20$ 和 $30$ 中都出现）。

3. **计算最小公倍数**：然后，将每个质因数的最高幂次相乘。这个乘积就是这些数的最小公倍数。对于上面的例子，LCM为 $2^2 \times 3 \times 5 = 4 \times 3 \times 5 = 60$。

4. **结果**：得到的乘积就是所求的最小公倍数。

这个方法适用于任意数量的整数。关键是要确保你包括了所有不同的质因数，并且每个质因数都是以它出现的最大幂次的形式出现的。

下面通过一个具体的例子来演示这个过程：

假设我们要找到 $12,15,18$ 的LCM。

- $12$ = $2^2 \times 3$
- $15$ = $3 \times 5$
- $18$ = $2 \times 3^2$

列出所有质因数：

- 对于 $2$，最高的幂次是 $2^2$（出现在 $12$ 中）。
- 对于 $3$，最高的幂次是 $3^2$（出现在 $18$ 中）。
- 对于 $5$，最高的幂次是 $5^1$（出现在 $15$ 中）。

计算LCM：

$$
\text{LCM} = 2^2 \times 3^2 \times 5 = 4 \times 9 \times 5 = 180
$$

所以， $12,15,18$ 的最小公倍数是 $180$。

根据上述原理，直接写出代码可以得到 $85$ 分。

考虑满分做法：

首先用埃筛求出 $\leq m$ 所有的质数。求出答案唯一分解的每一项次数。

对于每个质数 $p$，从大到小枚举次数 $a$，尝试 $p^a$ 能不能算入答案。枚举 $p^a$ 的每个倍数 $k\times p^a$，使用一个大小为 $m$ 的 `bool` 数组判断 $k\times p^a$ 有没有被限制掉。如果存在一个没有被限制的 $k\times p^a$，就把 $p^a$ 乘入答案里，枚举下一个质数；否则继续枚举 a。

时间复杂度 $O(n+m\log\log m)$


#### 参考代码

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MOD = 998234353;
const int MAXN = 3e6 + 100;
bool vis[MAXN], exi[MAXN];
signed main(void) {
    freopen("lcm.in", "r", stdin);
    freopen("lcm.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n, m;
    cin >> n >> m;
    while (n--) {
        int x;
        cin >> x;
        exi[x] = 1;
    }
    ll ans = 1;
    for (int i = 2; i <= m; ++i) {
        if (!vis[i]) {
            ll now = i, mx = 1;
            while (now <= m) {
                for (int j = now; j <= m; j += now) {
                    if (!exi[j]) {
                        mx = max(mx, now);
                        break;
                    }
                }
                now *= i;
            }
            ans = ans * mx % MOD;
            for (int j = i; j <= m; j += i) {
                vis[j] = 1;
            }
        }
    }
    cout << ans;
    return 0;
}
```

<div style="page-break-after: always"></div>
