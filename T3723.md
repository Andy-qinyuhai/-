# T3723 淘金热
### 题目背景

小G听说在一个迷宫里有宝藏！

这个迷宫一共有 $n$ 个节点，由 $n-1$ 条通道连接，其中宝藏在 $1$ 号节点。其中在若干个节点会被打通，有人会进入其中。他们**同时**会以每秒钟移动一个通道的速度向 $1$ 号节点移动。

在一开始的时候每个人都有一个热情度，当有两个人相遇的时候，热情度较小的那个会失去兴致，从而退出，热情度较大的那个因为看见有人退出，所以他的热情度会减去另一个退出的人的热情度的大小，然后继续移动。

宝藏只会在所有能到达 $1$ 号节点的人都到达了之后再打开。所以如果有人到达了 $1$ 号节点，但是还有人依旧没有失去兴致，那么他就会呆在 $1$ 号节点等待下一个人的到来。直到所有人都到达才结束。注意在 $1$ 号节点如果两个人相遇了也会让热情度更小的一个离开，让热情度更大的一个减去较小的那个然后留下来。

注意如果两个热情度相同的人相遇那么两个人就都会离开。

现在想求出最终在 $1$ 号节点获得宝藏的人的热情度。

### 题目描述

给定一棵有根二叉树，其中有若干个关键点有权值。开始时，每个关键点同时向上移动（可以理解为权值在移动），在某两个关键点相遇的时候，让权值较小的一个留下来（舍弃），另一个减去权值较小的那个继续向上移动。求最后根节点的值的大小。

每个关键点移动到根之后，如果没有其它点同时到达，那么它会停下来，等待下一个关键点到达根节点，直到最后一个能到达根节点的关键点到达后结束。

**如果两个权值相同的点相遇，那么两个关键点就都会停下来（舍弃）。**

保证根节点 $1$ 号节点只有一个儿子，且保证**一定有人能拿到宝藏**。


### 输入格式

第一行，一共两个整数 $n$ 和 $m$，分别表示节点总个数和有值的节点个数。

接下来 $n$ 行每行两个数 $ls_i,rs_i$，分别表示左右儿子的编号。若某个为零则表示没有该儿子。

接下来 $m$ 行，每行两个数 $x$ 和 $v$，表示编号 $x$ 的节点上有值为 $v$。


### 输出格式

一行，表示最终根节点的最后剩下的价值。

### 数据范围

对于 $20\\%$ 的数据， $2\le n\le 20$。

另有 $20\\%$ 的数据， $rs_i=0$。

另有 $20\\%$ 的数据，除根节点外，其它的节点构成一棵满二叉树。

对于 $100\\%$ 的数据， $2\le n\le 20000,2\le m\le n,1\le x\le n,0\le ls_i,rs_i\le n,1\le v\le 10^5$。

### 样例输入

```
6 5
2 0
3 4
5 6
0 0
0 0
0 0
1 3
3 6
4 2
5 2
6 4
```

### 样例输出

```
1
```

### 样例输入

```
8 4
2 0
3 4
5 6
0 8
0 0
0 7
0 0
0 0
2 6
6 7
8 5
7 1
```

### 样例输出

```
3
```

### 样例解释

![end21.jpg](https://res.jisuanke.com/img/upload/e6a9227ea70d07e50e06ebd785c3ae315cf0b901.jpg)

一开始各点上的权值为 `0,6,0,0,0,7,1,5`；

![end22.jpg](https://res.jisuanke.com/img/upload/20a20ae2b95d8e4ac6d38b3551628708a459c538.jpg)

$1s$ 之后变为 `6,0,7,5,0,0,1,0,0`；

到了第 $2s$ 的时候，有两个关键点在 $2$ 号节点相遇，此时大小为 $5$ 的留下，大小为 $7$ 的变为 $2$，继续向上跑；此刻 $1$ 号节点有关键点，但是有其他节点未到达，所以它就在 $1$ 号节点等待其它关键点到来；

![end23.jpg](https://res.jisuanke.com/img/upload/4708098ae8eae7280540976079979b33f2b8ab87.jpg)

所以 $2s$ 之后为 `6,2,1,0,0,0,0,0`；

到了第 $3s$ 的时候，有两个关键点在 $1$ 号节点相遇，此时大小为 $2$ 的留下，大小为 $6$ 的变为 $4$，虽然此时它在 $1$ 号节点，但是有其他节点未到达，所以它就继续在 $1$ 号节点等待其它关键点到来；

![end24.jpg](https://res.jisuanke.com/img/upload/64f96bec90a46ceb5fe8e048e378032323f75fe3.jpg)

所以 $3s$ 之后为 `4,1,0,0,0,0,0,0`；

到了第 $4s$ 的时候，有两个关键点在 $1$ 号节点相遇，此时大小为 $1$ 的留下，大小为 $4$ 的变为 $3$，由于此时只有它一个关键点，所以能到达 $1$ 号节点的都已经到达了，此时它就可以获得宝藏。

![end25.jpg](https://res.jisuanke.com/img/upload/954348a67c7f4ae386bb8587670c8357dede2010.jpg)

它的大小为 $3$，所以最终答案为 $3$。

### 题解

由于每个蒜头每个时刻都会向上走，所以我们拿一个数组用来存现在还在树上的蒜头，然后每次让他们所在的节点跳到他们的父亲上。

如果某一时刻，一个点出现了两个蒜头，那么就删去小的那个位置，另一个值减掉小的那个值。继续放回数组就好了。

一定要注意下图，两个 $5$ 相遇抵消，但是 $12$ 还没有走到根结点，此时就剩下一个结点有值，结束循环，这个时候只需要遍历哪一个结点上有值，该值就是答案。

![image.png](https://res.jisuanke.com/img/upload/65d1ca1e0fda88fa0a8a70086c97645e3c6c0fa8.png)

#### 参考代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 20005;
int n, m, a[N], fa[N];
vector<pair<int, int>> vc;
int calc(int x, int y) {
    if (x > y) {
        return x - y;
    }
    return y - x;
}
int main() {
    freopen("end.in", "r", stdin);
    freopen("end.out", "w", stdout);
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i) {
        int ls, rs;
        cin >> ls >> rs;
        if (ls) {
            fa[ls] = i;
        }
        if (rs) {
            fa[rs] = i;
        }
    }
    for (int i = 1; i <= m; ++ i) {
        int x, k;
        cin >> x >> k;
        a[x] = k;
        vc .push_back({ x, k});
    }
    while (m > 1) {
        memset(a, 0, sizeof(a));
        for (auto u: vc) {
            int x = u .first, k = u .second;
            if (x != 1) {
                x = fa[x];
            }
            if (a[x]) {
                a[x] = calc(a[x], k);
            } else {
                a[x] = k;
            }
        }
        vc .clear();
        m = 0;
        for (int i = 1; i <= n; ++ i) {
            if ( a[i] != 0) {
                vc .push_back({ i, a[i]}), ++ m;
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        if (a[i]) {
            cout << a[i] << endl;
            return 0;
        }
    }
    return 0;
}
```

<div style="page-break-after: always"></div>
