# T3725 吝啬的吃货

### 题目背景

小G 是个吃货，但是个吝啬的吃货。

对于一种食物（比如桃子啊，西瓜啊，大蒜啊～），小G 通常会对它们有两个定义：

*   一个是好吃指数 $a_i$；
*   一个是价钱 $b_i$。

如果要吃一个食物，自然要先买它，所以就要先付出代价。

而且 小G 的幸福指数计算方式非常奇怪，如果说吃的东西的**异或和**为 $A$，那么把这个 $A$ 转成二进制的数之后，如果第 $i$ 位（二进制最低位为第 $0$ 位）上为 $1$，那么就会增加 $c_i$ 的幸福值。

小G 想让幸福值减去总花费最大，你能帮帮它么？只需要告诉 小G 这个最大值是多少即可。

### 题目描述

有 $n$ 个物品，每个物品两种属性 $a_i,b_i$。可以从中选出若干物品，其代价为 $\sum b_i$。

对于选出来的数，设 $A=\oplus a_i$，那么对于 $A$ 二进制数中，若第 $i$ 位为 $1$，则有 $c_i$ 的收益。

注：这里的 $\oplus$ 指的是连续异或和。

求哪种选择物品的方案使得**收益减代价**的最大，输出最大的结果。可以不选。

### 输入格式

第一行两个整数 $n,m$， $n$ 表示物品个数， $m$ 表示数据的大小范围，具体含义参考数据范围。

接下来 $n$ 行，每行两个整数 $a_i$ 和 $b_i$，含义如上所示。

接下来一行 $m$ 个数，第 $i$ 个数表示 $c_{i-1}$。

### 输出格式

一行，表示最大收益。

### 数据范围

对于 $20\\%$ 的数据： $n\le 8,m\le 5$；

对于 $40\\%$ 的数据： $n\le 200$；

另有 $10\\%$ 的数据： $m=2$；

对于 $100\\%$ 的数据： $1\le n\le 10^4,1\le m\le 15,0\le a_i< 2^m,1\le b_i,c_i\le 10^9$。


### 样例输入

```
5 4
0 10
14 8
3 3
1 7
14 7
8 10 4 4
```

### 样例输出

```
15
```

### 样例输入

```
4 2
3 10
1 8
2 5
2 3
6 2
```

### 样例输出

```
0
```

### 样例解释

可以发现，不管选哪几个物品，都会亏损，所以最优的方案就是一个都不选。

总收益就是：`0`。


<div style="page-break-after: always"></div>

### 题解

线性动态规划题。

我们设状态 $f_i$ 表示异或和为 i 的最大收益。初始 $f_0=0$，其他全为一个极大值。

那么对于一个物品 $(a_i,b_i)$，我们就让所有的下标 $i$ 对下标为 $i\oplus a_i$ 的位置作贡献，然后直接更新数据就可以了。

但是这样会发现每次转移都要算一遍异或和为 i 的收益是多少，这显然是多余的。

那么我们可以改一改，改成 $f_i$ 表示异或和为 i 的最小花费为多少，最后再把收益加上就可以了。

记住统计答案的时候要从 $0\sim V$ 进行枚举，然后得到一个最大值。


#### 参考代码

```c++
#include <iostream>
#include <cstring>
using namespace std;
#define int long long
const int N = 10005, M = (1 << 16) + 5;
int n, m, V, a[N], b[N], c[25], f[M], g[M], ans;
signed main() {
    cin >> n >> m;
    V = (1 << m);
    for (int i = 1; i <= n; ++ i) {
        cin >> a[i] >> b[i];
    }
    for (int i = 0; i < m; ++ i) {
        cin >> c[i];
    }
    memset(f, 0x3f, sizeof(f));
    memset(g, 0x3f, sizeof(g));
    f[0] = g[0] = 0;
    for (int i = 1; i <= n; ++ i) {
        for (int j = 0; j < V; ++ j) {
            f[j] = min(f[j], g[j ^ a[i]] + b[i]);
        }
        for (int j = 0; j < V; ++ j) {
            g[j] = f[j];
        }
    }
    for (int i = 0; i < V; ++ i) {
        int res = -f[i];
        for (int j = 0; j < m; ++ j) {
            if ( i >> j& 1) {
                res += c[j];
            }
        }
        ans = max(ans, res);
    }
    cout << ans << "\n";
    return 0;
}
```

<div style="page-break-after: always"></div>
