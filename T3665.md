# 蒜头君逛游乐场

### 题目描述
<span></span>蒜头君今天来到了游乐场，游乐场有许许多多的娱乐项目，而聪明的蒜头君最爱解谜游戏，同时解谜成功的人可以获得精美奖品。

解谜游戏规则如下，有 $n$ 堆石子，每堆石子有 $a_i$ 个，玩家可以选择一些石子堆，将其中的石子全部拿走。规则要求，拿走的石子的总数必须为 $3$ 的倍数，你需要帮助蒜头君回答，他最多能拿走多少个石子？

### 输入格式

输入共两行，第一行输入一个数字 $n$ ，表示有 $n$ 堆石子。

第二行输入 $n$ 个数字 $a_i$ ，表示第 $i$ 堆石子的数量为 $a_i$ 个。

### 输出格式

输出一个数，表示答案，答案要求尽可能多的选石子，同时满足答案为 $3$ 的倍数。

### 数据范围

注意：部分答案有可能超出 $int$ 存储范围。

对于 $10\%$ 的数据，有 $n=1, 1\leq a_i\leq 10^5$。

对于另外 $20\%$ 的数据，有 $1\leq n\leq 3, 1\leq a_i\leq 10^5$。

对于另外 $20\%$ 的数据，有 $1\leq n\leq 10^5,1\leq a_i\leq 10^5$，对于这一部分的数据，一定有 $a_1=1,a_2=2$。

对于另外 $20\%$ 的数据，有 $1\leq n\leq 20, 1\leq a_i\leq 10^9$。

对于 $100\%$ 的数据，有$1\leq n\leq 10^5,\ 1\leq a_i\leq 10^9$。

<div style="page-break-after: always"></div>

### 题解
对于最开始 $10 \%$ 的数据，直接判断是否取余为 $0$ 即可。

对于 $n \leq 3$ 部分的数据而言，可以通过直接枚举所有可能 $O(1)$ 的时间解决。

对于 $a_1=1,a_2=2$ 的这一部分数据而言，可以直接求和后，看总和与 $3$ 取模的数值，来对应的减去 $a_1$ 或者 $a_2$。

对于 $n\leq 20$ 这部分数据而言，可以直接暴力求解，枚举每个数字选或是不选，复杂度为 $2^{20}\approx10^6$。

也就是对于这一题，不知道正解的情况下可以通过骗分得到 $70$ 分。

对于 $100\%$ 的数据，需要贪心计算，首先可以将数字分成三类，分别为模 $3$ 为 $0,1,2$ 的三类数字，同时记录数字总和。那么对于总和而言，也有三种情况，为模 $3$ 为 $0,1,2$ 三种。

如果总和模 $3$ 为 $0$，那么此时就是答案，可以直接输出。

如果总和模 $3$ 不为 $0$，那么我们它一定模 $3$ 为 $1$ 或 $2$。此时我们只需要找到最小的数模 $1$ 或 $2$ 的结果即可。

我们先将模为 $1$ 的数字和模为 $2$ 的数字收集起来并排序。

那么对于两个最小的模为 $1$ 的数，我们可以将最小的两个加起来作为模为 $2$ 的数，将其和归到模为 $2$ 的数字中；同样，两个模为 $2$ 的数，我们可以将其加起来作为模为 $1$ 的数，将其和归到模为 $1$ 的数字中。

之后我们对模为 $1,2$ 的数字分别再升序排序。

最后我们判断答案，若总和模为 $1$，则减去最小的模为 $1$ 的数字；否则减去最小的模为 $2$ 的数字。


#### 参考代码

```c++{.line-numbers}
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
int n, nums[maxn];
vector<int> m[4];
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &nums[i]);
    }
    long long sum = 0;
    for (int i = 0; i < n; i++) {
        sum += nums[i];
        m[nums[i] % 3].push_back(nums[i]);
    }
    if (sum % 3 == 0) {
        cout << sum << endl;
        return 0;
    }
    sort(m[1].begin(), m[1].end());
    sort(m[2].begin(), m[2].end());
    int flag = 0;
    if (m[1].size() >= 2) {
        m[2].push_back(m[1][0] + m[1][1]);
        flag = 1;
    }
    if (m[2].size() >= 2 + flag) {
        m[1].push_back(m[2][0] + m[2][1]);
    }
    sort(m[1].begin(), m[1].end());
    sort(m[2].begin(), m[2].end());
    long long ans;
    if (sum % 3 == 1) {
        ans = sum - m[1][0];
    } else {
        ans = sum - m[2][0];
    }
    cout << ans << endl;
    return 0;
}
```

<div style="page-break-after: always"></div>
