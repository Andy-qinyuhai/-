# 花色三角形

### 题目描述
#### 题目背景

蒜头君得意洋洋的望着染色问题专题说：“小意思，我学会了～”

花椰妹感觉蒜头君太自满了，她转发给蒜头君一道题目，准备为难一下蒜头君。

#### 题目描述

在一张 $n$ 个结点的 **无向完全图 G** 中，每条边有一种颜色（红色、绿色、蓝色），图中大部分边的颜色为绿色，部分边的颜色为红色或蓝色。

在 $G$ 中存在很多三角形（图中的顶点为三角形的顶点，图中的边为三角形的边），三角形共分为三种：

*   花色三角形：三条边的颜色**均不同**，价值为 $3$；
*   纯色三角形：三条边的颜色**均相同**，价值为 $-6$；
*   其他三角形：三条边只有两种颜色，价值为 $0$。

蒜头君需要求解出在 **无向完全图 G** 中，他可以获得的价值总和是多少。

### 输入格式

第一行以空格隔开输入两个正整数 $n,m$，分别表示 **无向完全图 G** 中顶点的个数、红色或蓝色边的个数；

接下来 $m$ 行，每行输入三个正整数 $u, v, c$，表示一条无向边 $(u,v)$ 的颜色为 $c$，若：

*   $c = 1$，该边为红色；
*   $c = 2$，该边为蓝色；

> 剩余边的颜色均为绿色。

### 输出格式

输出一个整数，**无向完全图 G** 中，蒜头君可以获得的价值总和。

### 数据范围

*   对于 $20\%$ 的数据，$1\leq n \leq 500, 1\leq m \leq \frac{n(n - 1)}{2}$；
*   对于 $40\%$ 的数据，$1\leq n \leq 2000, 1\leq m \leq \frac{n(n - 1)}{2}$；
*   对于 $100\%$ 的数据，$1\leq n \leq 100000, 1\leq m \leq \min\left(\frac{n(n - 1)}{2}, 200000\right)$；

<div style="page-break-after: always"></div>

### 题解
本题考查组合计数方法，算两次。

本题的关键是计算三角形的个数。一个角由一个顶点和两条边组成。

*   用 $A_1,A_2,A_3$ 分别表示两边为红蓝，红绿和蓝绿的角的个数。
*   用 $B_1,B_2,B_3$ 分别表示两边都是红，绿和蓝的角的个数。
*   用 $S$ 表示「花色三角形」的个数。
*   用 $T$ 表示三边「纯色三角形」的个数。
*   用 $L$ 表示「其它三角形」的个数，即只有两种颜色的三角形的个数。

用算两次的方法，我们可以得到：

*   $3S+2L=A_1+A_2+A_3$
*   $L+3T=B_1+B_2+B_3$

这样一来，价值和为：$3S-6T=A_1+A_2+A_3-2B_1-2B_2-2B_3$

注意到所有 $A_i$ 和 $B_i$ 都可以简单地通过算出每个节点连出的不同颜色的边的条数算出。

这样一来就可以在线性时间完成计算。


#### 参考代码

```c++{.line-numbers}
#include <bits/stdc++.h>
using namespace std;
const int maxn = 100010;
long long dr[maxn], dg[maxn], db[maxn];
int n, m;
int main() {
    freopen("triangle.in", "r", stdin);
    freopen("triangle.out", "w", stdout);
    scanf("%d %d", &n, &m);
    int a, b, c;
    for (int i = 1; i <= m; i++) {
        scanf("%d%d%d", &a, &b, &c);
        if (c == 1) {
            dr[a]++;
            dr[b]++;
        }
        if (c == 2) {
            dg[a]++;
            dg[b]++;
        }
    }
    for (int i = 1; i <= n; i++) {
        db[i] = (long long )(n - 1) - dr[i] - dg[i];
    }
    long long C = 0;
    for (int i = 1; i <= n; i++) {
        C += dr[i] * dg[i];
        C += dr[i] * db[i];
        C += dg[i] * db[i];
        C -= (long long )(dr[i] - 1) * dr[i];
        C -= (long long )(dg[i] - 1) * dg[i];
        C -= (long long )(db[i] - 1) * db[i];
    }
    printf("%lld\n", C);
    return 0;
}
```

<div style="page-break-after: always"></div>
