# 蒜头君组回文串

### 题目描述

蒜头君收到了一条 **非空的字符串** 。

一个 **非空字符串** ，如果从左到右和从右到左读取时都是相同的，被称为回文字符串。例如，字符串`abcba`、`a`和`abba`是回文字符串，而`abab`和`xy`则不是。

而同时，一个字符串被称为另一个字符串的子串，如果它可以通过从该字符串的开头和结尾删除一些（可能为零）字符来获得。例如，`abc`、`ab`和`c`是字符串`abc`的子串，而`ac`和`d`则不是。

蒜头君对于字符串的回文性质十分痴迷，因此，对于一个字符串，他定义了一个叫做`回文度`的概念：一个字符串的回文度是指字符串中有多少个**非空子串**是回文字符串。

现在，蒜头君希望你对他收到的字符串重新调整字符顺序，使得新字符串的回文度最大。

### 输入描述

输入共一行，仅由小写英文字母组成，代表蒜头君收到的字符串。

### 输出描述

输出一个正整数，代表最后蒜头君对收到的字符串重新调整字符顺序后可以达到的最大的回文度。

### 数据范围

本题共存在 $50$ 个测试点，各测试点详细信息见下表。

| 测试点编号 | 字符串长度 $n$ | 字符串满足的性质 |
| --- | --- | --- |
| $1\sim 5$ | $1\leq n\leq 10$ | 任意随机字符串 |
| $6\sim 10$ | $11\leq n\leq 10^3$ | 任意随机字符串 |
| $11\sim 15$ | $10^3\leq n\leq 10^5$ | 任意随机字符串 |
| $16\sim 20$ | $1\leq n\leq 10$ | 字符串内所有的字符均相同 |
| $21\sim 25$ | $11 \leq n\leq 10^3$ | 字符串内所有的字符均相同 |
| $26\sim 30$ | $10^3 \leq n\leq 10^5$ | 字符串内所有的字符均相同 |
| $31\sim 35$ | $1\leq n\leq 10$ | 字符串由两种字符组成，其中一种字符只有一个 |
| $36\sim 40$ | $11\leq n\leq 10^3$ | 字符串由两种字符组成，其中一种字符只有一个 |
| $41\sim 45$ | $10^3\leq n\leq 10^5$ | 字符串由两种字符组成，其中一种字符只有一个 |
| $46\sim 48$ | $10^5\leq n\leq 5\cdot 10^5$ | 字符串内所有的字符均相同 |
| $49\sim 50$ | $10^5\leq n\leq 5\cdot 10^5$ | 任意随机字符串 |

<div style="page-break-after: always"></div>

### 题解
一个可能的解决方案就是对字符串进行排序。

为什么这样做呢？

考虑简单的情形，对于只含有一种的字符串，我们要插入另一个字符。

设插入的位置为 $pos$，插入后，原字符串 $[pos-i,pos+j](i\neq j)$ 会因此不匹配。

所以这样不会使得插入的回文子串变多。因此让每个部分的字符都相同才是最佳方案。

每个回文都有相等的字符在其两端。假设这个字符是 $c$ ，出现的次数是 $x$ 。那么至多有 $\frac{x(x+1)}{2}$ 个回文有这个字符。

所以，我们有一个明确的答案上限。很容易看出，排序后的字符串满足这个上限，因此它是最优的答案。


#### 参考代码

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    string s;
    cin >> s;
    int cnt[30] = {0};
    for (int i = 0; i < s.size(); i++) {
        cnt[s[i] - 'a']++;
    }
    long long ans = 0;
    for (long long i = 0; i < 26; i++) {
        ans += (long long)cnt[i] * (cnt[i] + 1) / 2;
    }
    cout << ans;
    return 0;
}
```

<div style="page-break-after: always"></div>
