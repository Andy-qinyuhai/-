# 蒜头君的棋局

### 题目描述
国际象棋，是一款风靡全球的棋盘游戏，棋盘为一个 $n\times n$ 的矩阵。

国际象棋中实力最强的棋子为皇后，蒜头君最喜欢皇后，皇后可以上下左右对角线走（对角线有两条，从左上到右下和从右上到左下），且移动距离不限。因为蒜头君过于偏爱皇后，蒜头君制定了一条新的规则，那就是所有与皇后在同一横线、同一竖线、同一对角线（两条对角线）的敌方小兵都可以被皇后攻击。

蒜头君找来了一块 $n\times n$ 的棋盘，上面有 $m$ 个敌方小兵，坐标分别为 $(k_i,k_j)$（ $1\leq k_i,k_j\leq n$）。其中，棋盘的左上角为 $(1,1)$ 坐标。

现在，蒜头君想知道，在他制定的规则下，对于一个坐标为 $(i,j)$ 的皇后能够攻击到的小兵数量是多少。

### 输入格式

第一行输入一个正整数 $n$，表示棋盘大小。

接下来 $n$ 行，每行输入 $n$ 个数，用来表示在当前位置有没有小兵， $0$ 表示当前位置没有小兵， $1$ 表示当前位置存在一个小兵。

接下来一个输入一个正整数 $q$，表示接下来询问对于 $q$ 个皇后。

接下来 $q$ 行，每行输入两个正整数 $(i,j)$，表示当前询问的皇后的位置。

### 输出格式

输出共 $q$ 行，每行输出一个整数，表示对于当前棋局，每个皇后分别能攻击到多少个小兵。

### 数据范围

数据不保证皇后所摆放的位置没有士兵。

对于 $10\\%$ 的数据，有 $2\leq n\leq 10, 1\leq q\leq 10$。

对于另外 $20\\%$ 的数据，有 $2\leq n\leq 100, 1\leq q\leq 100$。

对于另外 $20\\%$ 的数据，有 $2\leq n\leq 10^3, q=1$。

对于 $100\\%$ 的数据，有 $2\leq n\leq 10^3, 1\leq q\leq 10^5$。

<div style="page-break-after: always"></div>

### 题解
以 $4\times 4$ 的矩阵为例。  $$ \begin{matrix} (1,1) & (1,2) & (1,3) & (1,4) \\ (2,1) & (2,2) & (2,3) & (2,4) \\ (3,1) & (3,2) & (3,3) & (3,4) \\ (4,1) & (4,2) & (4,3) & (4,4) \end{matrix}$$ 矩阵内存储的二元组为其对应元素的坐标。

皇后可以向上下无限攻击，向左右无限攻击，所以我们只需要预处理出对应的前缀和，即可在 $O(1)$ 的时间内回答行列的答案。

对于两条对角线，我们发现：

*   从右上到左下的对角线， $i+j$ 的值都是相等的，比如说 $(1,3),(2,2),(3,1)$ 这条对角线上的 $i,j$ 之和都为 $4$。

*   从左上到右下的对角线， $i-j$ 的值是相等的，比如说 $(1,2),(2,3),(3,4)$ 这条对角线上的 $i,j$ 之差都为 $1$。

所以我们可以利用这条性质，将对角线的和也求出，然后 $O(1)$ 回答每一个询问。


#### 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1010;
const int p = 1010;
int a[maxn][maxn];
int z[maxn * 3]; // 主对角线
int f[maxn * 3]; // 副对角线
int r[maxn]; // 行
int c[maxn]; // 列
int main() {
    int n, q;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            z[i + j] += a[i][j];
            f[i - j + p] += a[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            r[i] += a[i][j];
        }
    }
    for (int j = 1; j <= n; j++) {
        for (int i = 1; i <= n; i++) {
            c[j] += a[i][j];
        }
    }
    cin >> q;
    while (q--) {
        int i, j;
        cin >> i >> j;
        int ans = z[i + j] + f[i - j + p] + r[i] + c[j] - 3 * a[i][j];
        cout << ans << endl;
    }
    return 0;
}
```

<div style="page-break-after: always"></div>
